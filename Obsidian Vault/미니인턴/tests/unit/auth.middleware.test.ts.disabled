import { Request, Response, NextFunction } from 'express';
import { authenticate, requireAdmin } from '../../src/middleware/auth';
import * as jwtUtils from '../../src/utils/jwt';
import UserService from '../../src/services/user';

// Mock dependencies
jest.mock('../../src/utils/jwt');
jest.mock('../../src/services/user');

const mockJwtUtils = jwtUtils as jest.Mocked<typeof jwtUtils>;
const mockUserService = UserService as jest.MockedClass<typeof UserService>;

describe('Auth Middleware', () => {
  let mockRequest: Partial<Request>;
  let mockResponse: Partial<Response>;
  let mockNext: NextFunction;

  beforeEach(() => {
    mockRequest = {
      headers: {},
      user: undefined
    };
    
    mockResponse = {
      status: jest.fn().mockReturnThis(),
      json: jest.fn().mockReturnThis()
    };
    
    mockNext = jest.fn();
    
    jest.clearAllMocks();
  });

  describe('authenticate', () => {
    it('should authenticate valid token successfully', async () => {
      const mockUser = {
        id: 'user-id',
        email: 'test@example.com',
        isAdmin: false
      };

      const mockPayload = {
        id: 'user-id',
        email: 'test@example.com',
        isAdmin: false
      };

      mockRequest.headers = {
        authorization: 'Bearer valid-token'
      };

      mockJwtUtils.verifyToken.mockReturnValue(mockPayload);
      mockUserService.prototype.getUserById.mockResolvedValue(mockUser);

      await authenticate(mockRequest as Request, mockResponse as Response, mockNext);

      expect(mockJwtUtils.verifyToken).toHaveBeenCalledWith('valid-token');
      expect(mockUserService.prototype.getUserById).toHaveBeenCalledWith('user-id');
      expect(mockRequest.user).toEqual(mockUser);
      expect(mockNext).toHaveBeenCalledWith();
    });

    it('should reject request without authorization header', async () => {
      mockRequest.headers = {};

      await authenticate(mockRequest as Request, mockResponse as Response, mockNext);

      expect(mockResponse.status).toHaveBeenCalledWith(401);
      expect(mockResponse.json).toHaveBeenCalledWith({
        success: false,
        error: {
          code: 'UNAUTHORIZED',
          message: 'Authentication required. Please provide a valid access token.'
        },
        requestId: expect.any(String),
        timestamp: expect.any(String)
      });
      expect(mockNext).not.toHaveBeenCalled();
    });

    it('should reject malformed authorization header', async () => {
      mockRequest.headers = {
        authorization: 'Invalid-Format'
      };

      await authenticate(mockRequest as Request, mockResponse as Response, mockNext);

      expect(mockResponse.status).toHaveBeenCalledWith(401);
      expect(mockResponse.json).toHaveBeenCalledWith({
        success: false,
        error: {
          code: 'UNAUTHORIZED',
          message: 'Invalid authorization header format. Expected: Bearer <token>'
        },
        requestId: expect.any(String),
        timestamp: expect.any(String)
      });
      expect(mockNext).not.toHaveBeenCalled();
    });

    it('should reject invalid token', async () => {
      mockRequest.headers = {
        authorization: 'Bearer invalid-token'
      };

      mockJwtUtils.verifyToken.mockImplementation(() => {
        throw new Error('Invalid token');
      });

      await authenticate(mockRequest as Request, mockResponse as Response, mockNext);

      expect(mockResponse.status).toHaveBeenCalledWith(401);
      expect(mockResponse.json).toHaveBeenCalledWith({
        success: false,
        error: {
          code: 'UNAUTHORIZED',
          message: 'Invalid or expired token. Please log in again.'
        },
        requestId: expect.any(String),
        timestamp: expect.any(String)
      });
      expect(mockNext).not.toHaveBeenCalled();
    });

    it('should reject when user not found in database', async () => {
      const mockPayload = {
        id: 'non-existent-user',
        email: 'test@example.com',
        isAdmin: false
      };

      mockRequest.headers = {
        authorization: 'Bearer valid-token'
      };

      mockJwtUtils.verifyToken.mockReturnValue(mockPayload);
      mockUserService.prototype.getUserById.mockResolvedValue(null);

      await authenticate(mockRequest as Request, mockResponse as Response, mockNext);

      expect(mockResponse.status).toHaveBeenCalledWith(401);
      expect(mockResponse.json).toHaveBeenCalledWith({
        success: false,
        error: {
          code: 'UNAUTHORIZED',
          message: 'User not found. Please log in again.'
        },
        requestId: expect.any(String),
        timestamp: expect.any(String)
      });
      expect(mockNext).not.toHaveBeenCalled();
    });

    it('should handle database errors', async () => {
      const mockPayload = {
        id: 'user-id',
        email: 'test@example.com',
        isAdmin: false
      };

      mockRequest.headers = {
        authorization: 'Bearer valid-token'
      };

      mockJwtUtils.verifyToken.mockReturnValue(mockPayload);
      mockUserService.prototype.getUserById.mockRejectedValue(new Error('Database error'));

      await authenticate(mockRequest as Request, mockResponse as Response, mockNext);

      expect(mockResponse.status).toHaveBeenCalledWith(500);
      expect(mockResponse.json).toHaveBeenCalledWith({
        success: false,
        error: {
          code: 'INTERNAL_SERVER_ERROR',
          message: 'An error occurred during authentication'
        },
        requestId: expect.any(String),
        timestamp: expect.any(String)
      });
      expect(mockNext).not.toHaveBeenCalled();
    });

    it('should handle expired token', async () => {
      mockRequest.headers = {
        authorization: 'Bearer expired-token'
      };

      const tokenError = new Error('Token expired');
      tokenError.name = 'TokenExpiredError';
      mockJwtUtils.verifyToken.mockImplementation(() => {
        throw tokenError;
      });

      await authenticate(mockRequest as Request, mockResponse as Response, mockNext);

      expect(mockResponse.status).toHaveBeenCalledWith(401);
      expect(mockResponse.json).toHaveBeenCalledWith({
        success: false,
        error: {
          code: 'UNAUTHORIZED',
          message: 'Token has expired. Please log in again.'
        },
        requestId: expect.any(String),
        timestamp: expect.any(String)
      });
    });
  });

  describe('requireAdmin', () => {
    it('should allow admin user to proceed', () => {
      mockRequest.user = {
        id: 'admin-id',
        email: 'admin@example.com',
        isAdmin: true
      };

      requireAdmin(mockRequest as Request, mockResponse as Response, mockNext);

      expect(mockNext).toHaveBeenCalledWith();
      expect(mockResponse.status).not.toHaveBeenCalled();
    });

    it('should reject non-admin user', () => {
      mockRequest.user = {
        id: 'user-id',
        email: 'user@example.com',
        isAdmin: false
      };

      requireAdmin(mockRequest as Request, mockResponse as Response, mockNext);

      expect(mockResponse.status).toHaveBeenCalledWith(403);
      expect(mockResponse.json).toHaveBeenCalledWith({
        success: false,
        error: {
          code: 'FORBIDDEN',
          message: 'Access denied. Admin privileges required.'
        },
        requestId: expect.any(String),
        timestamp: expect.any(String)
      });
      expect(mockNext).not.toHaveBeenCalled();
    });

    it('should reject when user is not set in request', () => {
      mockRequest.user = undefined;

      requireAdmin(mockRequest as Request, mockResponse as Response, mockNext);

      expect(mockResponse.status).toHaveBeenCalledWith(401);
      expect(mockResponse.json).toHaveBeenCalledWith({
        success: false,
        error: {
          code: 'UNAUTHORIZED',
          message: 'Authentication required. Please log in first.'
        },
        requestId: expect.any(String),
        timestamp: expect.any(String)
      });
      expect(mockNext).not.toHaveBeenCalled();
    });

    it('should handle user with missing isAdmin property', () => {
      mockRequest.user = {
        id: 'user-id',
        email: 'user@example.com'
        // isAdmin property missing
      } as any;

      requireAdmin(mockRequest as Request, mockResponse as Response, mockNext);

      expect(mockResponse.status).toHaveBeenCalledWith(403);
      expect(mockResponse.json).toHaveBeenCalledWith({
        success: false,
        error: {
          code: 'FORBIDDEN',
          message: 'Access denied. Admin privileges required.'
        },
        requestId: expect.any(String),
        timestamp: expect.any(String)
      });
      expect(mockNext).not.toHaveBeenCalled();
    });
  });
});